<h1 uiAnchor id="自定义组件">自定义组件</h1>

<p>TextBus 中组件和现在前端流行的组件是差不多的。组件一般有一段基本固定的结构，可以通过属性或方法更改组件的数据，达到定制组件的目的。同时组件也可以有任意个子插槽，插槽中的内容可以任意编辑。</p>

<p>虽然 TextBus 中组件和传统 web 开发中的组件差不多，但毕竟 TextBus 中的组件是为了富文本编辑用的，还是需要遵循一些规则，才能更好的实现我们想要编辑的功能。TextBus 把组件分为了以下 4 种：</p>

<div class="ui-form-group">
  <label class="ui-control-label ui-control-label-compact"><code>DivisionComponent</code> <br><small>区块组件</small></label>
  <div class="ui-control-static">
    只有一个子插槽的组件，我们可以把 HTML 部分标签看成是这类组件，如：p、div、article、blockquote 等。实际上，在 TextBus 默认的组件中，就是把原生的 p、div 等封装成 DivisionComponent 组件。<br>
    当然，DivisionComponent 也可以扩展其它自定义的结构，维一限制就是，有且只有一个子插槽。
  </div>
</div>
<div class="ui-form-group">
  <label class="ui-control-label ui-control-label-compact"><code>BranchComponent</code> <br><small>分支组件</small></label>
  <div class="ui-control-static">
    有固定结构和多个子插槽，且子插槽可任意增加、删除等，如 ul>li、ol>li 等。也可以其它用户自定义的组件，如 TextBus 官方组件库提供的待办事项组件。
  </div>
</div>
<div class="ui-form-group">
  <label class="ui-control-label ui-control-label-compact"><code>BackboneComponent</code> <br><small>骨架组件</small></label>
  <div class="ui-control-static">
    有固定结构和多个子插槽，且子插槽不可随意增删，如 table 下面的 td，td 有多个，但不可随意添加和删除，否则会引起表格错乱，只能通过组件提供的方法，或其它方式，按照一定的规则修改。TextBus 的表格和组件库中的卡片就是继承自 BackboneComponent 的组件。
  </div>
</div>
<div class="ui-form-group">
  <label class="ui-control-label ui-control-label-compact"><code>LeafComponent</code> <br><small>叶组件</small></label>
  <div class="ui-control-static">
    没有子插槽的组件。如 img、video、audio、br 等，组件本身就是最叶子的组件。
  </div>
</div>
<div class="ui-alert ui-alert-dark ui-alert-fill"><strong class="ui-color-danger">注意：</strong>在 TextBus 中开发组件，必须继承自上面 4 种组件中的一种，并实现其抽象方法，只有这样，TextBus 提供的各项基础能力才能更好的处理富文本编辑的逻辑。</div>
<p>下面，我们以开发一个 div 组件为例，来初步解开 TextBus 组件的面纱！</p>

<h2 uiAnchor id="第一个组件">第一个组件</h2>

<link rel="markdown" href="./extend-component.md">

<h2 uiAnchor id="开发组件时常见问题">开发组件时常见问题</h2>
<table>
  <tbody>
  <tr>
    <td>Q:</td>
    <td>我的 ComponentReader 怎么不生效？</td>
  </tr>
  <tr>
    <td>A:</td>
    <td><p>TextBus 在初始化时，会遍历整个 HTML 树，并调用配置项中的 ComponentReader 来转换成 TextBus 所需要抽象数据，当匹配某一个 HTML 元素时，只要有一个解析器匹配上，则后面的将不再匹配。要解决此问题，你可以把自己开发解析器，添加在 TextBus 配置项的 componentReaders 数组的前面，以调整优先级。</p></td>
  </tr>

  <tr>
    <td>Q:</td>
    <td>我组件里面的内容不见了？</td>
  </tr>
  <tr>
    <td>A:</td>
    <td>
      <p>由于组件的形态是不固定的，所以 TextBus 在渲染组件后代内容时，不知道要把后代内容放置在组件的什么位置。这时，TextBus 会调用组件的 <code>getSlotView</code> 方法，根据返回的虚拟 DOM 元素，插入后代内容。在调用 <code>getSlotView</code> 方法时，如果是 <code>BranchComponent</code> 或 <code>BackboneComponent</code> 组件类时，还会传入当前的 slot，方便组件根据 slot 返回对应的虚拟 DOM 元素。</p>
      <p>由于 <code>BranchComponent</code> 和 <code>BackboneComponent</code> 总是要维护虚拟 DOM 和 slot 的映射关系，所以 <code>BranchComponent</code> 和 <code>BackboneComponent</code> 默认自带了一个 <code>viewMap</code> 的 Map 对象，当组件渲染时，需要实时把 slot 和虚拟 DOM 的对应关系保存在 <code>viewMap</code> 中。</p>
    </td>
  </tr>

  <tr>
    <td>Q:</td>
    <td>我要怎么定制组件的交互行为？</td>
  </tr>
  <tr>
    <td>A:</td>
    <td>
      <p>常见的编辑交互事件，可以订阅虚拟 DOM 元素的 events，并根据不同的事件类型，做不同的操作。如果要监听浏览器原生事件，可以通过 render 方法的第二个参数获取到 <code>NativeEventManager</code> 对象<small>（组件 render 方法的第二个参数，该对象只有在编辑模式才会存在）</small>，然后再监听事件，并定制交互行为。
      </p>
      <p>如果，以上还不能满足需求，还可以通过添加 TextBus 生命周期类，来订制你想要的功能！</p>
    </td>
  </tr>

  <tr>
    <td>Q:</td>
    <td>为什么我在绑定原生事件的回调里修改了数据，页面没有实时渲染出来？</td>
  </tr>
  <tr>
    <td>A:</td>
    <td>
      <p>如果是通过 NativeEventManager 对象绑定的原生事件，TextBus 会在事件执行完毕之后，更新变化，但有的时候，可能通过其它方式添加了事件，这时，TextBus 并不知道某个元素绑定的事件里会做什么操作。出于性能考虑，TextBus 也不会去监听内容变化，而是每次操作后，通过通知告诉 TextBus 需要更新 DOM。</p>
      <p>一般情况下，TextBus 默认的事件系统已经能够满足大部分需求，但还是有一些情况不在预料中，如原生事件修改了 TextBus 的数据。这时，需要手动发布事件，让 TextBus 知道，内容变化了。请参考下面的示例：</p>
      <div class="ui-alert ui-alert-dark ui-alert-fill"><strong class="ui-color-danger">注意：</strong>下面的示例是不好的实践，这里只是为了说明怎么样发布事件，最好不要参考下面的示例去实现功能！</div>
      <link rel="markdown" href="./1.md">
    </td>
  </tr>
  </tbody>
</table>

<div class="doc-quick-links">
  <a uiAnchorLink routerLink="./" fragment="自定义组件">自定义组件</a>
  <a uiAnchorLink routerLink="./" fragment="第一个组件">第一个组件</a>
  <a uiAnchorLink routerLink="./" fragment="创建-Commander-类">创建 Commander 类</a>
  <a uiAnchorLink routerLink="./" fragment="创建工具条工具">创建工具条工具</a>
  <a uiAnchorLink routerLink="./" fragment="把新工具配置-TextBus-中">把新工具配置 TextBus 中</a>
  <a uiAnchorLink routerLink="./" fragment="组件解析器">组件解析器</a>
  <a uiAnchorLink routerLink="./" fragment="开发组件时常见问题">开发组件时常见问题</a>
</div>
